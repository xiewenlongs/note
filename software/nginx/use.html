

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>use &mdash; Notebook</title>
  

  
  
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Notebook" href="../../index.html"/>
        <link rel="up" title="nginx" href="index.html"/>
        <link rel="next" title="implement" href="implement.html"/>
        <link rel="prev" title="demo config" href="conf.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> 一剑光寒起书楼
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../program_lang/index.html">编程语言</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../network/index.html">计算机网络</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">技术</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../django.html">django</a></li>
<li class="toctree-l2"><a class="reference internal" href="../flask.html">flask</a></li>
<li class="toctree-l2"><a class="reference internal" href="../github.html">github</a></li>
<li class="toctree-l2"><a class="reference internal" href="../goaccess.html">goaccess</a></li>
<li class="toctree-l2"><a class="reference internal" href="../hadoop.html">hadoop</a></li>
<li class="toctree-l2"><a class="reference internal" href="../list.html">list</a></li>
<li class="toctree-l2"><a class="reference internal" href="../lucene.html">lucene</a></li>
<li class="toctree-l2"><a class="reference internal" href="../maven.html">maven</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mongo.html">mongo</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mongoengine.html">mongoengine</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mysql.html">mysql</a></li>
<li class="toctree-l2"><a class="reference internal" href="../oss.html">云存储</a></li>
<li class="toctree-l2"><a class="reference internal" href="../scrapy.html">scrapy</a></li>
<li class="toctree-l2"><a class="reference internal" href="../sentry.html">sentry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../solr.html">solr</a></li>
<li class="toctree-l2"><a class="reference internal" href="../supervisord.html">supervisord</a></li>
<li class="toctree-l2"><a class="reference internal" href="../uwsgi.html">uwsgi</a></li>
<li class="toctree-l2"><a class="reference internal" href="../vim.html">vim</a></li>
<li class="toctree-l2"><a class="reference internal" href="../webbench.html">webbench</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html">nginx</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="conf.html">demo config</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">use</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id1">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id2">安装</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id6">配置</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id12">反向代理</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id14">性能调优</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id17">其他</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id19">扩展</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id20">问题</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="implement.html">implement</a></li>
<li class="toctree-l3"><a class="reference internal" href="struct.html">struct</a></li>
<li class="toctree-l3"><a class="reference internal" href="faq.html">FAQ</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../python-lib/index.html">python库</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../linux/index.html">linux 笔记</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../arithmetic/index.html">算法</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../mind/index.html">思考</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tools.html">Tools</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">一剑光寒起书楼</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">技术</a> &raquo;</li>
      
          <li><a href="index.html">nginx</a> &raquo;</li>
      
    <li>use</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="use">
<h1>use<a class="headerlink" href="#use" title="Permalink to this headline">¶</a></h1>
<div class="section" id="id1">
<h2>简介<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>nginx 是开源、多平台的http 服务器，以下是它的特性:</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
<img alt="../../_images/s_nginx_feature.png" src="../../_images/s_nginx_feature.png" />
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>nginx 虽然是开源的，但Igor Sysoev 已为nginx 成立公司，提供商业级的产品与支持</p>
</div>
<div class="section" id="id2">
<h2>安装<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id3">
<h3>依赖<a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h3>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="26%" />
<col width="51%" />
<col width="23%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">依赖库</th>
<th class="head">作用</th>
<th class="head">备注</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PCRE(required)</td>
<td>正则匹配</td>
<td>无</td>
</tr>
<tr class="row-odd"><td>zlib(required)</td>
<td>gzip 压缩使用</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>openssl</td>
<td>https 需要</td>
<td>&nbsp;</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id4">
<h3>编译<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h3>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>configure选项</p>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="34%" />
<col width="66%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">选项(默认安装)</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8211;with-rtsig-module (no)</td>
<td>使用rtsig module 处理事件驱动. 默认情况下， nginx 不安装rtsig module</td>
</tr>
<tr class="row-odd"><td>&#8211;with-select_module (no)</td>
<td>使用select module 处理事件驱动. 如果nginx 没有找到epoll, 该模块将会被安装</td>
</tr>
<tr class="row-even"><td>&#8211;without-select_module (no)</td>
<td>不使用select module 处理事件驱动</td>
</tr>
<tr class="row-odd"><td>&#8211;with-poll_module (no)</td>
<td>与select 模块类似，默认不会安装</td>
</tr>
<tr class="row-even"><td>&#8211;without-poll_module (no)</td>
<td>不使用poll module 处理事件驱动</td>
</tr>
<tr class="row-odd"><td>&#8211;with-aio_module (no)</td>
<td>使用AIO方式处理文件访问</td>
</tr>
<tr class="row-even"><td>&#8211;without-http_charset_module (yes)</td>
<td>这个模块可以降服务器发出的http响应重新编码</td>
</tr>
<tr class="row-odd"><td>&#8211;without-http_gzip_module (yes)</td>
<td>&nbsp;</td>
</tr>
<tr class="row-even"><td>&#8211;without-http-ssi_module (yes)</td>
<td>该模块可以在Response 中加入特定的内容，如html固定页头/页尾</td>
</tr>
<tr class="row-odd"><td>&#8211;without-http_userid_module (yes)</td>
<td>这个模块可以通过HTTP请求头，认证用户信息，以确定请求是否合法</td>
</tr>
<tr class="row-even"><td>&#8211;without-http_access_module (yes)</td>
<td>这个模块可以限制客户端IP</td>
</tr>
<tr class="row-odd"><td>&#8211;without-http_auth_basic_module</td>
<td>这个模块可以提供最简单的用户密码验证</td>
</tr>
<tr class="row-even"><td>&#8211;without-http_autoindex_module</td>
<td>目录浏览功能</td>
</tr>
<tr class="row-odd"><td>&#8211;without-http_geo_module</td>
<td>这个模块可以定义一些变量，这些变量的值与客户端IP地址关联. 例如: 这样Nginx
针对不同地域显示不同的语言</td>
</tr>
<tr class="row-even"><td>&#8211;without-http_map_module</td>
<td>这个模块可以建立一个key/value映射表, 这样可以针对不同的url做特殊处理</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>configure 脚本的主要目的是 <code class="docutils literal"><span class="pre">检测编译依赖库是否存在</span></code> , <code class="docutils literal"><span class="pre">生成ngx_modules.c文件</span></code></p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="id5">
<h3>信号操作<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h3>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">信号</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>nginx -s stop</td>
<td>停止服务</td>
</tr>
<tr class="row-odd"><td>nginx -s quit</td>
<td>优雅的停止服务</td>
</tr>
<tr class="row-even"><td>nginx -s reload</td>
<td>重载配置</td>
</tr>
<tr class="row-odd"><td>nginx -s reopen</td>
<td>日志文件回滚</td>
</tr>
<tr class="row-even"><td>kill -s SIGUSR2</td>
<td>平滑升级nginx</td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id6">
<h2>配置<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<div class="section" id="core">
<h3>core模块<a class="headerlink" href="#core" title="Permalink to this headline">¶</a></h3>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">选项</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>daemon &lt;on&gt;</td>
<td>是否以daemon方式运行。默认是on, 提供off的目的是为了开发调试</td>
</tr>
<tr class="row-odd"><td>master_process &lt;on&gt;</td>
<td>是否启动worker进程。 同上，提供off只是为了调试</td>
</tr>
<tr class="row-even"><td>timer_resolution &lt;time&gt;</td>
<td>By default, gettimeofday() is called each time a kernel event is received.
With reduced resolution, gettimeofday() is only called once per specified this.</td>
</tr>
<tr class="row-odd"><td>pid &lt;path&gt;</td>
<td>pid文件路径，默认在&lt;prefix/logs/nginx.pid&gt;</td>
</tr>
<tr class="row-even"><td>lock_file &lt;path&gt;</td>
<td>nginx 多个进程访问共享内存时，需要用lock来同步，但现在的nginx都用的是atomic,
所以这个指令相当于已经废弃</td>
</tr>
<tr class="row-odd"><td>user &lt;user&gt;</td>
<td>worker进程的owner</td>
</tr>
<tr class="row-even"><td>worker_processes &lt;num&gt;</td>
<td>指定worker进程个数, 可以设置为``auto``, nginx自动检测CPU核心数</td>
</tr>
<tr class="row-odd"><td>worker_rlimit_nofile &lt;int&gt;</td>
<td><strong>102400</strong>  设置一个worker进程可以打开的最大文件句柄数</td>
</tr>
<tr class="row-even"><td>worker_priority &lt;num&gt;</td>
<td>nginx进程优先级, 默认-10. 值越低, 优先级越高。 注意优先级不要设置太高，否则
系统调用的优先级会被比下去</td>
</tr>
<tr class="row-odd"><td>worker_cpu_affinity &lt;...&gt;</td>
<td>CPU亲和性</td>
</tr>
<tr class="row-even"><td>worker_rlimit_core</td>
<td>coredump 文件的最大大小</td>
</tr>
<tr class="row-odd"><td>worker_rlimit_sigpending</td>
<td>只对RTSIG 系统有用。On systems that support rtsig connection processing
method, changes the limit on the number of signals that may be queued
(RLIMIT_SIGPENDING) for worker processes. Used to increase the limit without
restarting the main process</td>
</tr>
<tr class="row-even"><td>working_directory &lt;path&gt;</td>
<td>Defines the current working directory for a worker process. It is primarily
used when writing a core-file</td>
</tr>
<tr class="row-odd"><td>env &lt;...&gt;</td>
<td>默认的，nginx的worker进程会清除从parent继承来的所有环境变量, 这个指令可以保留
部分变量</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="event">
<h3>event模块<a class="headerlink" href="#event" title="Permalink to this headline">¶</a></h3>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="19%" />
<col width="10%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">选项</th>
<th class="head">模块</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>worker_connections &lt;num&gt;</td>
<td>event_core</td>
<td>一个worker进程可以建立的最大连接总数, 它不能超过 worker_rlimit_nofile, 否则
没有意义. 默认512</td>
</tr>
<tr class="row-odd"><td>connections &lt;num&gt;</td>
<td>event_core</td>
<td>貌似被废弃了, nginx文档里没有这个指令, 从代码看默认512</td>
</tr>
<tr class="row-even"><td>use &lt;event&gt;</td>
<td>event_core</td>
<td>使用那种connection processing method, nginx默认会选择最高效的方式</td>
</tr>
<tr class="row-odd"><td>multi_accept &lt;on&gt;</td>
<td>event_core</td>
<td>当事件模型通知有新请求时，尽可能对本次调度中客户端的所有TCP请求都建立连接,
默认off. 如果同一时间过来的请求量太大，一个worker进程会花费很多在accept上，
所以这时应该关闭</td>
</tr>
<tr class="row-even"><td>accept_mutex &lt;on&gt;</td>
<td>event_core</td>
<td><ol class="first last arabic simple">
<li><code class="docutils literal"><span class="pre">避免惊群效果</span></code> (每个 accept 上一把锁);</li>
<li><code class="docutils literal"><span class="pre">负载平衡</span></code> (如果当前worker的请求量已达到worker_connections的7/8， 则这个worker 不参与竞争新来的request) ,默认是on</li>
</ol>
</td>
</tr>
<tr class="row-odd"><td>accept_mutex_delay</td>
<td>event_core</td>
<td>和accept_mutex 配合用, 如果一个worker进程未拥有accept mutex，它至少延迟这么
长时间之后再尝试抢夺, 默认500ms</td>
</tr>
<tr class="row-even"><td>epoll_events &lt;num&gt;</td>
<td>epoll</td>
<td>??????, 默认512</td>
</tr>
<tr class="row-odd"><td>worker_aio_requests &lt;num&gt;</td>
<td>epoll</td>
<td>??????, 默认32</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="http">
<h3>http模块<a class="headerlink" href="#http" title="Permalink to this headline">¶</a></h3>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="25%" />
<col width="13%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">选项</th>
<th class="head">模块</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>error_log</td>
<td>errlog</td>
<td>改变error log 路径, 默认是 /prefix/logs/error.log</td>
</tr>
<tr class="row-odd"><td>client_header_timeout</td>
<td>http_core</td>
<td>收到一个请求后,nginx 建立与客户端的TCP链接, 链接建立后开始read
客户端发送的数据。如果这个客户端是个hacker, 它hung住来浪费nginx
资源，那么nginx在这段时间内会一直维持着这个连接。此参数设置
nginx等待时间，如果超过时间，nginx直接返回408错误, 默认60s</td>
</tr>
<tr class="row-even"><td>client_body_timeout &lt;time&gt;</td>
<td>http_core</td>
<td>同上，请求体超时</td>
</tr>
<tr class="row-odd"><td>connection_pool_size</td>
<td>http_core</td>
<td>nginx为一个连接能开辟内存的上限, 默认256. 这个值对性能调优效果很小，不应该设置</td>
</tr>
<tr class="row-even"><td>request_pool_size</td>
<td>http_core</td>
<td>nginx为一个请求能开辟的内存上限，默认4k, 这个值对性能调优效果很小，不应该设置</td>
</tr>
<tr class="row-odd"><td>client_header_buffer_size</td>
<td>http_core</td>
<td>处理一个请求头最大开辟的内存大小, 默认1k</td>
</tr>
<tr class="row-even"><td>large_client_header_buffers</td>
<td>http_core</td>
<td>处理一个请求头，如果请求过大，超过client_header_buffer_size指定缓存，那么使用
这个设置项</td>
</tr>
<tr class="row-odd"><td>client_max_body_size &lt;size&gt;</td>
<td>http_core</td>
<td>根据请求头的content-Length, 来限制请求. 若超出限制，nginx 返回413</td>
</tr>
<tr class="row-even"><td>client_body_buffer_size &lt;num&gt;</td>
<td>http_core</td>
<td>一个请求的请求体需要存在内存中， 这个值指定了buffer大小, 如果超过这个值，
nginx 会把请求体写入磁盘</td>
</tr>
<tr class="row-odd"><td>client_body_in_file_only &lt;on&gt;</td>
<td>http_core</td>
<td>对于一个请求，如果请求体过大，超过client_body_buffer_size大小</td>
</tr>
<tr class="row-even"><td>client_body_temp_path</td>
<td>http_core</td>
<td>同上，如果请求过大，nginx会把请求存在临时文件中</td>
</tr>
<tr class="row-odd"><td>sendfile &lt;on&gt;</td>
<td>http_core</td>
<td>启用sendfile 系统调用，来减少static file 请求时，用户态和内核态的切换时间</td>
</tr>
<tr class="row-even"><td>aio</td>
<td>http_core</td>
<td>使用AIO方式来访问静态文件服务, 和sendfile互斥。两者谁好谁坏很难定论, nginx
论坛上，建议使用AIO, 因为sendfile对预读的控制不好. 应使用aio + directio</td>
</tr>
<tr class="row-odd"><td>tcp_nodelay &lt;on&gt;</td>
<td>http_core</td>
<td>对keepalive连接是否使用TCP_NODELAY选项, 与NOPUSH选项互斥， 其实是关闭
Nagle&#8217;s 算法， Nagle 是避免传输数据小，网络带宽无法有效利用，将多个数据组
包一起发送, 但是HTTP的数据更多是偏向流处理，而不是类似telnet,等待用户输入
数据, 所以默认是TCP_NODELAY 开启</td>
</tr>
<tr class="row-even"><td>send_timeout</td>
<td>http_core</td>
<td>nginx 返回response 给客户端的时候，每发送一个packet， 都希望收到ack, 如果在
这个指定的时间内，没有收到ack, 说明client可能掉了，那么关闭连接</td>
</tr>
<tr class="row-odd"><td>keepalive_requests &lt;num&gt;</td>
<td>http_core</td>
<td>nginx 建立一个keep alive 连接后，在这个连接上处理了&lt;num&gt;个请求后，就关闭连接</td>
</tr>
<tr class="row-even"><td>keepalive_disable &lt;...&gt;</td>
<td>http_core</td>
<td>nginx 可以设置对哪些浏览器不keep alive, 可选的有: msie6, safari</td>
</tr>
<tr class="row-odd"><td>satisfy &lt;...&gt;</td>
<td>http_core</td>
<td>nginx 有多种限制access的方式，如ip, base_auth, 这个指令是决定把所有限制&lt;与&gt;
还是&lt;或&gt;</td>
</tr>
<tr class="row-even"><td>log_not_found &lt;on&gt;</td>
<td>http_core</td>
<td>访问不存在的文件， 这种请求是否记录在error log里, 默认记录&lt;on&gt;</td>
</tr>
<tr class="row-odd"><td>server_tokens &lt;on&gt;</td>
<td>http_core</td>
<td>在错误response是否显示nginx版本, 默认on</td>
</tr>
<tr class="row-even"><td>error_page</td>
<td>http_core</td>
<td>error_page 500 502 503 504 /50x.html;</td>
</tr>
<tr class="row-odd"><td>try_files</td>
<td>http_core</td>
<td>try file</td>
</tr>
<tr class="row-even"><td>error_log</td>
<td>http_core</td>
<td>指定error log路径</td>
</tr>
<tr class="row-odd"><td>open_file_cache &lt;max&gt; &lt;inact&gt;</td>
<td>http_core</td>
<td><strong>max=102400 inactive=20s</strong>  open_file_cache 会告诉 Nginx 去缓存打开的文件，
“未找到”的错误，有关文件的元 数据和他们的权限，等等。这样做的好处是，一个高
需求的文件要求时，Nginx 的可以 立即开始发送数据；而且也知道立即发送一个 404,
但是，有一个不太理想的缺点：如果磁盘上有变化，服务器不会立即作出反应。 最多
缓存&lt;max&gt;个， 非活跃的缓存 &lt;inact&gt;秒后从缓存剔除</td>
</tr>
<tr class="row-even"><td>open_file_cache_valid &lt;time&gt;</td>
<td>http_core</td>
<td><strong>30s</strong> 而活动（最近要求的文件）每&lt;time&gt;秒重新验证一次。</td>
</tr>
<tr class="row-odd"><td>open_file_cache_min_uses</td>
<td>http_core</td>
<td>如果定义活跃的item, 这个指令就是定义: 在&lt;inact&gt;时间内至少访问过 &lt;time&gt;次</td>
</tr>
<tr class="row-even"><td>open_file_cache_errors</td>
<td>http_core</td>
<td>缓存404</td>
</tr>
<tr class="row-odd"><td>resolver</td>
<td>http_core</td>
<td>配置nginx 内部的DNS服务器</td>
</tr>
<tr class="row-even"><td>resolver_timeout</td>
<td>http_core</td>
<td>配置DNS查询超时</td>
</tr>
<tr class="row-odd"><td>read_ahead &lt;size&gt;</td>
<td>http_core</td>
<td>???</td>
</tr>
<tr class="row-even"><td>lingering_close &lt;on&gt;</td>
<td>http_core</td>
<td>???</td>
</tr>
<tr class="row-odd"><td>lingering_time &lt;on&gt;</td>
<td>http_core</td>
<td>???</td>
</tr>
<tr class="row-even"><td>lingering_timeout &lt;on&gt;</td>
<td>http_core</td>
<td>???</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id7">
<h3>其他模块<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="25%" />
<col width="13%" />
<col width="61%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">选项</th>
<th class="head">模块</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>error_log</td>
<td>errlog</td>
<td>改变error log 路径, 默认是 /prefix/logs/error.log</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id8">
<h3>基本配置<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">选项</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>user &lt;用户名&gt;</td>
<td>worker进程的执行用户</td>
</tr>
<tr class="row-odd"><td>use &lt;事件模型&gt;</td>
<td>选择事件模型(如: epoll)</td>
</tr>
<tr class="row-even"><td>listen &lt;num...&gt;</td>
<td><p class="first">监听端口, 它有以下参数:</p>
<p><strong>default_server</strong>: 默认server, nginx 可能有多个server配置，设置这个后当前
server就成为默认server(server_name没有匹配)</p>
<p><strong>bind</strong>: 当设置 listen xx.xx.xx.xx:80 时，默认nginx 不会限制IP, 就是不会绑定
xx.xx.xx.xx这个IP接口， 设置bind则绑定</p>
<p><strong>fastopen</strong>: 打开TCP fastopen选项, TCP fastopen特性只有kernel 版本大于3才支持
这个参数水很深，不要随便设置</p>
<p><strong>backlog &lt;num&gt;</strong>: 默认512, 修改完net.core.somaxconn之后一定要修改这个，否则
等于没改</p>
<p class="last"><strong>deferred</strong>: 默认新来一个TCP连接，三次握手后master进程就唤醒worker进程来
接待。 设置这个参数后，三次握手完成master并不立 刻唤醒worker, 而是这个连接
上真来了数据，才唤醒worker, 它减轻了worker的负担。降低服务端进行
epoll_ctl、epoll_wait（linux下）的次数（系统调用）和降低服务端保持的连接句柄数
<code class="docutils literal"><span class="pre">需要根据业务特征来决定</span></code></p>
</td>
</tr>
<tr class="row-odd"><td>server_name &lt;...&gt;</td>
<td><p class="first">虚拟主机配置, nginx 检测request头的HOST字段，拿来匹配server, 按以下顺序匹配:</p>
<ol class="arabic simple">
<li>字符串完全匹配, 如: www.test.com</li>
<li>通配符前匹配, 如: *.test.com</li>
<li>通配符后匹配, 如: www.test.*</li>
<li>正则匹配, 如: ~^(?&lt;user&gt;.+).example.net$; (注意，正则表达式前要增加~)</li>
<li>都没有匹配， 使用default_server</li>
</ol>
<p class="last">server_name 是忽略大小写的，因为它是把server_name转成小写</p>
</td>
</tr>
<tr class="row-even"><td>server_names_hash_bucket_size</td>
<td>为了提高快速找到server_name的能力， nginx使用了散列桶， 这个参数指定散列桶的
大小， 越大越占内存，但速度越快. 默认32|64|128</td>
</tr>
<tr class="row-odd"><td>server_names_hash_max_size</td>
<td>效果同上. 默认512</td>
</tr>
<tr class="row-even"><td>server_name_in_redirect &lt;yes&gt;</td>
<td>重定向的时候，把原请求里的HOST, 换成server_name写的第一个主机名</td>
</tr>
<tr class="row-odd"><td>location &lt;...&gt;</td>
<td>用请求中的url来匹配, 见 <a class="reference internal" href="#nginx-location"><span>location</span></a></td>
</tr>
<tr class="row-even"><td>alias &lt;path&gt;</td>
<td>指定文件路径</td>
</tr>
<tr class="row-odd"><td>root &lt;path&gt;</td>
<td>指定文件路径(和alias 互为两种方式)</td>
</tr>
<tr class="row-even"><td>index &lt;path&gt;</td>
<td>指定主页的html文件, 默认为(index.html)</td>
</tr>
<tr class="row-odd"><td>error_page &lt;code&gt; &lt;url&gt;</td>
<td>错误重定向, 出现&lt;code&gt;对应的错误response时，nginx 把结果重定向到url</td>
</tr>
<tr class="row-even"><td>resursive_error_pages &lt;on&gt;</td>
<td>是否打开&#8221;错误重定向&#8221;的递归</td>
</tr>
<tr class="row-odd"><td>try_files &lt;path1&gt; &lt;path2&gt; &lt;url&gt;</td>
<td>按顺序尝试每一个path</td>
</tr>
<tr class="row-even"><td>limit_except {...}</td>
<td>按http方法, 限制客户端请求种类, 见 <a class="reference internal" href="#nginx-limit-except"><span>limit_except</span></a></td>
</tr>
<tr class="row-odd"><td>limit_rate &lt;num&gt;</td>
<td>对每一个TCP连接限速</td>
</tr>
<tr class="row-even"><td>ignore_invalid_headers &lt;on&gt;</td>
<td>如果出现不合法的HTTP头部时， nginx 会忽略错误继续处理。但如果这个选项被off
nginx 会直接返回400</td>
</tr>
<tr class="row-odd"><td>underscores_in_headers &lt;on&gt;</td>
<td>http头部是否允许带下划线</td>
</tr>
<tr class="row-even"><td>log_not_found &lt;on&gt;</td>
<td>404是否记录日志</td>
</tr>
<tr class="row-odd"><td>merge_slashes &lt;on&gt;</td>
<td>是否合并url中相邻的/, 如: //test//a.txt 会变成 /test/a.txt</td>
</tr>
<tr class="row-even"><td>resolver &lt;ip&gt;</td>
<td>设置DNS服务器地址</td>
</tr>
<tr class="row-odd"><td>resolver_timeout &lt;time&gt;</td>
<td>DNS解析超时时间, 默认30s</td>
</tr>
<tr class="row-even"><td>server_tokens &lt;on&gt;</td>
<td>返回错误页面时，是否在server中注明nginx版本, 默认on</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="id9">
<h3>内部资源分配<a class="headerlink" href="#id9" title="Permalink to this headline">¶</a></h3>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">选项</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>connnection_pool_size &lt;num&gt;</td>
<td>每个TCP连接分配的内存池初始大小, 默认256, 如果这个值太大，内存占用会很多，
如果很小，造成分配次数增多</td>
</tr>
<tr class="row-odd"><td>send_timeout &lt;time&gt;</td>
<td>nginx 向客户端发送了数据，但客户端超过这么长时间都没有去接收数据，那么
nginx 会关闭这个连接</td>
</tr>
<tr class="row-even"><td>reset_timeout_connection</td>
<td>??? 向客户端发送RST来关闭连接， 减少服务端的FIN-WAIT状态套接字</td>
</tr>
<tr class="row-odd"><td>lingering_close</td>
<td>???</td>
</tr>
<tr class="row-even"><td>lingering_time</td>
<td>???</td>
</tr>
<tr class="row-odd"><td>lingering_timeout</td>
<td>???</td>
</tr>
<tr class="row-even"><td>keepalive_disable &lt;...&gt;</td>
<td>对某些浏览器禁用 keepalive 功能</td>
</tr>
<tr class="row-odd"><td>keepalive_timeout &lt;time&gt;</td>
<td>keepalive 超时时间, 每个http1.1的连接， 默认nginx都是长连接,超时时间由
这个值来定</td>
</tr>
<tr class="row-even"><td>keepalive_requests &lt;num&gt;</td>
<td>一个keepalive 连接上默认最多能发送的request 个数</td>
</tr>
<tr class="row-odd"><td>tcp_nopush &lt;on&gt;</td>
<td>是否开启FreeDSB的TCP_NOPUSH 或Linux 的TCP_CORK功能</td>
</tr>
<tr class="row-even"><td>proxy_buffering &lt;on&gt;</td>
<td>proxy服务器接收后端upstream响应的时候，是否使用buffer先把response缓存起
来，等upstream处理完了，再全部send到客户端. 打开的好处是， 只要代理nginx
和后端nginx交互完后，就可以关闭这条链接，减少upstream服务器开销，这对于
客户端响应很慢的情况来说，是很有利的，后端之间的链接，不用等客户端响应</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="id10">
<h3>文件访问<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">选项</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>open_file_cache</td>
<td>???</td>
</tr>
<tr class="row-odd"><td>open_file_cache_errors</td>
<td>???</td>
</tr>
<tr class="row-even"><td>open_file_cache_min_uses</td>
<td>???</td>
</tr>
<tr class="row-odd"><td>open_file_cache_valid</td>
<td>???</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="mime">
<h3>MIME<a class="headerlink" href="#mime" title="Permalink to this headline">¶</a></h3>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">选项</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>type {...}</td>
<td>配置文件扩展名与mime映射</td>
</tr>
<tr class="row-odd"><td>default_type &lt;...&gt;</td>
<td>默认MIME类型</td>
</tr>
<tr class="row-even"><td>types_hash_bucket_size</td>
<td>上面映射的散列桶大小</td>
</tr>
<tr class="row-odd"><td>types_hash_max_size</td>
<td>上面散列桶的个数</td>
</tr>
</tbody>
</table>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
<div class="section" id="id11">
<h3>性能调优<a class="headerlink" href="#id11" title="Permalink to this headline">¶</a></h3>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="27%" />
<col width="73%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">选项</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>worker_cpu_affinity &lt;...&gt;</td>
<td>worker和CPU绑定 (仅对Linux系统起作用， 内部调用sched_setaffinity()来实现,
示例: worker_cpu_affinity 1000 0100 0010 0001</td>
</tr>
<tr class="row-odd"><td>ssl_engine &lt;device&gt;</td>
<td>ssl硬件加速。如果服务器上有SSL硬件加速设备，就可以用这个指令配置</td>
</tr>
<tr class="row-even"><td>timer_resolution &lt;time&gt;</td>
<td>默认情况下，每次内核事件调用，都要执行一次 gettimeofday</td>
</tr>
<tr class="row-odd"><td>worker_prority &lt;int&gt;</td>
<td>在Linux系统中，每个进程都有优先级，范围为[-19,+20], -19优先级最高,
如果想让分配CPU资源的时候，多分给nginx, 可以增加nginx优先级，默认nginx 值
为0 (不建议低于-5, 内核进程的优先级)</td>
</tr>
<tr class="row-even"><td>accept_mutex &lt;on&gt;</td>
<td><ol class="first last arabic simple">
<li><code class="docutils literal"><span class="pre">避免惊群效果</span></code> (每个 accept 上一把锁);</li>
<li><code class="docutils literal"><span class="pre">负载平衡</span></code> (如果当前worker的请求量已达到worker_connections的7/8，
则这个worker 不参与竞争新来的request)</li>
</ol>
</td>
</tr>
<tr class="row-odd"><td>multi_accept &lt;on&gt;</td>
<td>当事件模型通知有新请求时，尽可能对本次调度中客户端的所有TCP请求都建立连接</td>
</tr>
<tr class="row-even"><td>worker_connections</td>
<td>每个worker 的连接池大小。 所以:
<code class="docutils literal"><span class="pre">nginx能接收的总的连接数</span> <span class="pre">=</span> <span class="pre">worker_connections</span> <span class="pre">*</span> <span class="pre">worker_processes</span></code></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="id12">
<h2>反向代理<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<img alt="../../_images/s_nginx_rproxy.png" src="../../_images/s_nginx_rproxy.png" />
<p>Nginx代理和squid代理机制不太一样， 客户端发送请求， nginx代理服务器接收完整个请求，才向upstream转发请求， 这样做的目的
主要是 <code class="docutils literal"><span class="pre">降低upstream</span></code> 的压力. 因为客户端到nginx代理之间一般式走外网， 速度较慢。 而代理和upstream之间一般式走内网，
速度很快</p>
<div class="section" id="buffer">
<h3>buffer<a class="headerlink" href="#buffer" title="Permalink to this headline">¶</a></h3>
<p>Nginx proxy use buffer default. Without buffers, data is sent from the proxied server and immediately begins to be
transmitted to the client. If the clients are assumed to be fast, buffering can be turned off in order to get the
data to the client as soon as possible. With buffers, the Nginx proxy will temporarily store the backend&#8217;s response
and then feed this data to the client. If the client is slow, this allows the Nginx server to close the connection
to the backend sooner. It can then handle distributing the data to the client at whatever pace is possible.</p>
<p>If you want turn it off, you should set <code class="docutils literal"><span class="pre">proxy_buffering</span></code> to off</p>
<p>refer: <a class="reference external" href="https://www.digitalocean.com/community/tutorials/understanding-nginx-http-proxying-load-balancing-buffering-and-caching">https://www.digitalocean.com/community/tutorials/understanding-nginx-http-proxying-load-balancing-buffering-and-caching</a></p>
</div>
<div class="section" id="id13">
<h3>负载均衡<a class="headerlink" href="#id13" title="Permalink to this headline">¶</a></h3>
<p>upstream负载均衡有两种机制: <code class="docutils literal"><span class="pre">ip_hash</span></code> 和 <code class="docutils literal"><span class="pre">weight</span></code></p>
<p>ip_hash 是nginx按客户端ip, 自动的把请求打在上游集群中特定一台, 配置如下:</p>
<div class="highlight-python"><div class="highlight"><pre>upstream backend {
    ip_hash
    server backend1.example.com;
    server backend2.example.com;
    server backend3.example.com;
}
</pre></div>
</div>
<p>weight 是按权重来分流量， 配置如下:</p>
<div class="highlight-python"><div class="highlight"><pre>upstream backend {
    server backend1.example.com weight=2 max_fails=3 fail_timeout=30s;
    server backend2.example.com weight=2 max_fails=2 fail_timeout=20s;
    server backend3.example.com weight=1;
}
</pre></div>
</div>
<p>一份反向代理配置如下:</p>
<div class="highlight-python"><div class="highlight"><pre>upstream real.sites {

    server 123.123.123.123;

    // 用keepalive保存长连接，降低频繁创建连接的开销
    keepalive 16;
}

proxy_cache_path /path/to/cache levels=1:2 keys_zone=static_cache:100m;

server {
    server_name     www.example.com;

    // 把真正的IP地址放到header的X-Forwarded-For里面
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

    proxy_http_version 1.1;

    proxy_set_header Connection &quot;&quot;;

    # 当某一个上游返回503错误时， nginx 继续换一个上游转发
    # 默认一个上游返回错误时，nginx是不会换一个上游转发的
    proxy_next_upstream http_503;

    // 把静态资源缓存起来，减少服务器间数据传输
    location ~ \.(css|js|jpg|png|gif|ico)$ {

    proxy_cache static_cache;

    proxy_pass http://real.sites;
    }

    location / {
        proxy_pass http://real.sites;
    }
}
</pre></div>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="id14">
<h2>性能调优<a class="headerlink" href="#id14" title="Permalink to this headline">¶</a></h2>
<div class="section" id="id15">
<h3>内核参数调优<a class="headerlink" href="#id15" title="Permalink to this headline">¶</a></h3>
<p>见 <a class="reference internal" href="../../linux/tuning.html#http-core-tuning"><span>内核调优</span></a></p>
</div>
<div class="section" id="debug-nginx">
<h3>debug nginx<a class="headerlink" href="#debug-nginx" title="Permalink to this headline">¶</a></h3>
<p>方法1: 打开 &#8211;with-debug</p>
<p>方法2: Debugging nginx with DTrace pid provider</p>
<p>相关链接: <a class="reference external" href="http://nginx.org/en/docs/nginx_dtrace_pid_provider.html">http://nginx.org/en/docs/nginx_dtrace_pid_provider.html</a></p>
</div>
<div class="section" id="id16">
<h3>减少系统调用<a class="headerlink" href="#id16" title="Permalink to this headline">¶</a></h3>
<p>系统调用的开销是比较大的，因为它会从用户态进入内核态，再退出, x这种切换是比较昂贵的. 我们可以通过配置nginx来减少不必要的系统调用，如: open/gettimeofday</p>
<p>通过strace命令来查看nginx接受一个请求会调用哪些系统调用，然后分析可以通过配置关闭的调用, 如: gettimeofday</p>
<div class="line-block">
<div class="line"><br /></div>
</div>
</div>
</div>
<div class="section" id="id17">
<h2>其他<a class="headerlink" href="#id17" title="Permalink to this headline">¶</a></h2>
<div class="section" id="location">
<span id="nginx-location"></span><h3>location 配置<a class="headerlink" href="#location" title="Permalink to this headline">¶</a></h3>
<p><code class="docutils literal"><span class="pre">=</span></code> 匹配符， 完全匹配才处理， e.g:</p>
<div class="highlight-python"><div class="highlight"><pre>location = / {
     # 完全匹配才处理, 只处理url/
     ...
}
</pre></div>
</div>
<p><code class="docutils literal"><span class="pre">~</span></code> 匹配符， 表示执行一个正则匹配, 大小写敏感</p>
<p><code class="docutils literal"><span class="pre">~*</span></code> 匹配符， 表示执行一个正则匹配, 大小写不敏感</p>
<p><code class="docutils literal"><span class="pre">^~</span></code> 表示普通字符匹配，如果该选项匹配，只匹配该选项，不匹配别的选项，一般用来匹配目录</p>
<p>可以使用正则, e.g:</p>
<div class="highlight-python"><div class="highlight"><pre>location  = / {
     # 只匹配&quot;/&quot;.
     [ configuration A ]
}

location  / {
     # 匹配任何请求，因为所有请求都是以&quot;/&quot;开始
     # 但是更长字符匹配或者正则表达式匹配会优先匹配
     [ configuration B ]
}

location ^~ /images/ {
     # 匹配任何以 /images/ 开始的请求，并停止匹配 其它location
     [ configuration C ]
}

location ~* \.(gif|jpg|jpeg)$ {
     # 匹配以 gif, jpg, or jpeg结尾的请求.
     # 但是所有 /images/ 目录的请求将由 [Configuration C]处理.
     [ configuration D ]
}
</pre></div>
</div>
</div>
<div class="section" id="log">
<h3>log 配置<a class="headerlink" href="#log" title="Permalink to this headline">¶</a></h3>
<p>log配置有四个指令:</p>
<div class="highlight-python"><div class="highlight"><pre>error_log logs/error.log warn;
log_format gzip &#39;$remote_addr - $remote_user [$time_local] &#39;
                &#39;&quot;$request&quot; $status $bytes_sent &#39;
                &#39;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &quot;$gzip_ratio&quot;&#39;;

access_log /spool/logs/nginx-access.log gzip buffer=32k;
open_log_file_cache max=1000 inactive=20s valid=1m min_uses=2;
</pre></div>
</div>
<p>默认的error日志，在logs/error.log. 默认的access日志， 在logs/access.log. 可以通过 <code class="docutils literal"><span class="pre">log_format</span></code> 指令来定义format, 然后
在access_log指令里用.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">尽量不要在log 路径里写变量， 否则nginx 每写一条日志，都要打开关闭一次文件描述符, 虽然可以用open_log_file_cache 指令
来优化这点，但还是很影响性能</p>
</div>
<div class="line-block">
<div class="line"><br /></div>
</div>
<p>写log时默认使用同level的log配置, 如果当前level没有log配置, 就继承上层配置。如果当前level有多个log配置，那么每个配置都写
一遍</p>
</div>
<div class="section" id="don-t-use-if">
<h3>Don&#8217;t use If<a class="headerlink" href="#don-t-use-if" title="Permalink to this headline">¶</a></h3>
<p>IfIsEvil: <a class="reference external" href="http://wiki.nginx.org/IfIsEvil">http://wiki.nginx.org/IfIsEvil</a></p>
</div>
<div class="section" id="nginx-limit-except">
<span id="id18"></span><h3>限制请求方法<a class="headerlink" href="#nginx-limit-except" title="Permalink to this headline">¶</a></h3>
<p>配置:</p>
<div class="highlight-python"><div class="highlight"><pre>limit_except GET POST DELETE {
    deny all;
}
</pre></div>
</div>
<p>意思是， 除了GET POST DELETE 方法外，其他一切请求都deny</p>
</div>
</div>
<div class="section" id="id19">
<h2>扩展<a class="headerlink" href="#id19" title="Permalink to this headline">¶</a></h2>
<table border="1" class="table-bordered docutils">
<colgroup>
<col width="30%" />
<col width="70%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">模块</th>
<th class="head">作用</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>nginx_upstream_check_module</td>
<td>upstream 集群健康监测模块</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="id20">
<h2>问题<a class="headerlink" href="#id20" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="implement.html" class="btn btn-neutral float-right" title="implement" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="conf.html" class="btn btn-neutral" title="demo config" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  false
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>